/***************************************************************************************************************
 * @file           : app.c                                                             P A C K   E M U L A T O R
 * @brief          : Implementation of application
 ***************************************************************************************************************
 *
 * Copyright (c) 2023 Modular Battery Technologies, Inc
 *
 **************************************************************************************************************/
// Include files
#include "app.h"
#include "main.h"
#include "canfdspi_api.h"
#include "battery.h"
#include "string.h"
#include "stdio.h"
#include "can_id_module.h"
#include "can_frm_mod.h"

/***************************************************************************************************************
*
*                               Section: Global Data Definitions                       P A C K   E M U L A T O R
*
***************************************************************************************************************/


APP_DATA appData;

CAN_CONFIG config;
CAN_OPERATION_MODE opMode;

// Transmit objects
CAN_TX_FIFO_CONFIG txConfig;
CAN_TX_FIFO_EVENT txFlags;
CAN_TX_MSGOBJ txObj;
uint8_t txd[MAX_DATA_BYTES];

// Receive objects
CAN_RX_FIFO_CONFIG rxConfig;
REG_CiFLTOBJ fObj;
REG_CiMASK mObj;
CAN_RX_FIFO_EVENT rxFlags;
CAN_RX_MSGOBJ rxObj;
uint8_t rxd[MAX_DATA_BYTES];

uint32_t delayCount = APP_LED_TIME;

REG_t reg;

APP_SwitchState lastSwitchState;

APP_Payload payload;

uint8_t ledCount = 0, ledState = 0;

uint8_t i;

CAN_BUS_DIAGNOSTIC busDiagnostics;
uint8_t tec;
uint8_t rec;
CAN_ERROR_STATE errorFlags;


extern char tempBuffer[MAX_BUFFER];
extern uint8_t canRxInterrupt;
extern uint8_t canTxInterrupt;
extern void serialOut(char* message);

void APP_ProcessHardwareRequest(void);


/***************************************************************************************************************
*
*                   Section: Application Local Functions                               P A C K   E M U L A T O R
*
***************************************************************************************************************/

void APP_LED_Clear(uint8_t led)
{
    switch (led) {
        case 0://LED_Off(LED0);
        	HAL_GPIO_WritePin(LED5_RED_GPIO_Port,  LED5_RED_Pin , GPIO_PIN_RESET);
            break;
        case 1: //LED_Off(LED1);
        	HAL_GPIO_WritePin(LED4_GREEN_GPIO_Port,  LED4_GREEN_Pin , GPIO_PIN_RESET);
            break;
        case 2: //LED_On(LED2);
            HAL_GPIO_WritePin(LED6_BLUE_GPIO_Port,  LED6_BLUE_Pin , GPIO_PIN_RESET);
            break;
        default: break;
    }
}

void APP_LED_Set(uint8_t led)
{
    switch (led) {
        case 0: //LED_On(LED0);
        	HAL_GPIO_WritePin(LED5_RED_GPIO_Port,  LED5_RED_Pin , GPIO_PIN_SET);
            break;
        case 1: //LED_On(LED1);
        	HAL_GPIO_WritePin(LED4_GREEN_GPIO_Port,  LED4_GREEN_Pin , GPIO_PIN_SET);
            break;
        case 2: //LED_On(LED2);
            HAL_GPIO_WritePin(LED6_BLUE_GPIO_Port,  LED6_BLUE_Pin , GPIO_PIN_SET);
            break;
        default: break;
    }
}

void APP_LED_Write(uint8_t led)
{
    uint8_t mask, pin;

    mask = 1;
    pin = 0;
    Nop();

    for (i = 0; i < APP_N_LED; i++, pin++) {
        if (led & mask) {
            // Set LED
            APP_LED_Set(pin);
        } else {
            // Clear LED
            APP_LED_Clear(pin);
        }

        mask = mask << 1;
    }
}

/***************************************************************************************************************
*
*       Section: Application Initialization and State Machine Functions                P A C K   E M U L A T O R
*
***************************************************************************************************************/


/***************************************************************************************************************
*     A P P _ I n i t i a l i z e                                                      P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_Initialize(void)
{


  //clear the batteryModule Array
  memset(module,0,sizeof(module));

  //set up a couple of modules
  //module[0]
  module[0].mfgId           = 0xDC;
  module[0].partId          = 0x01;
  module[0].uniqueId        = 0xBA770001;
  module[0].mmv             = 400;// 10 bit MMV = 0 to 1023
  module[0].mmc             = 300;// 10 bit MMV = 0 to 1023
  module[0].state           = moduleOff;
  module[0].fwVersion       = 8200;
  module[0].hwVersion       = 1000;
  module[0].maxChargeA      = 65535;
  module[0].maxDischargeA   = 0;
  module[0].maxChargeEndV      = 400/0.15;
  module[0].voltHi          = 3;
  module[0].voltLo          = 2;
  module[0].voltAvg         = 2;
  module[0].tempHi          = 50;
  module[0].tempLo          = 48;
  module[0].tempAvg         = 49;
  module[0].soc             = 90;
  module[0].cellCount       = 5;
  module[0].cell[0].voltage = 1;
  module[0].cell[0].temp    = 48;
  module[0].cell[0].soc     = 90;
  module[0].cell[0].soh     = 100;
  module[0].cell[1].voltage = 1;
  module[0].cell[1].temp    = 48;
  module[0].cell[1].soc     = 90;
  module[0].cell[1].soh     = 90;
  module[0].cell[2].voltage = 1;
  module[0].cell[2].temp    = 48;
  module[0].cell[2].soc     = 90;
  module[0].cell[2].soh     = 100;
  module[0].cell[3].voltage = 1;
  module[0].cell[3].temp    = 49;
  module[0].cell[3].soc     = 90;
  module[0].cell[3].soh     = 99;
  module[0].cell[4].voltage = 1;
  module[0].cell[4].temp    = 50;
  module[0].cell[4].soc     = 91;
  module[0].cell[4].soh     = 100;
  moduleCount++;

  //module[1]
  module[1].mfgId           = 0xDC;
  module[1].partId          = 0x01;
  module[1].uniqueId        = 0xBA770002;
  module[1].mmv             = 401;// 10 bit MMV = 0 to 1023
  module[1].mmc             = 200;// 10 bit MMV = 0 to 1023
  module[1].state           = moduleOff;
  module[1].fwVersion       = 8200;
  module[1].hwVersion       = 1000;
  module[1].maxChargeA      = 65535;
  module[1].maxDischargeA   = 0;
  module[1].maxChargeEndV      = 400/0.15;
  module[1].voltHi          = 3;
  module[1].voltLo          = 2;
  module[1].voltAvg         = 2;
  module[1].tempHi          = 50;
  module[1].tempLo          = 48;
  module[1].tempAvg         = 49;
  module[1].soc             = 90;
  module[1].cellCount       = 5;
  module[1].cell[0].voltage = 1;
  module[1].cell[0].temp    = 48;
  module[1].cell[0].soc     = 90;
  module[1].cell[0].soh     = 96;
  module[1].cell[1].voltage = 1;
  module[1].cell[1].temp    = 48;
  module[1].cell[1].soc     = 90;
  module[1].cell[1].soh     = 97;
  module[1].cell[2].voltage = 1;
  module[1].cell[2].temp    = 48;
  module[1].cell[2].soc     = 90;
  module[1].cell[2].soh     = 98;
  module[1].cell[3].voltage = 1;
  module[1].cell[3].temp    = 49;
  module[1].cell[3].soc     = 90;
  module[1].cell[3].soh     = 99;
  module[1].cell[4].voltage = 1;
  module[1].cell[4].temp    = 49;
  module[1].cell[4].soc     = 91;
  module[1].cell[4].soh     = 100;
  moduleCount++;


  serialOut("");
  serialOut("");
  serialOut("        ██    ██");
  serialOut("     ██ ██ ██ ██ ██");
  serialOut("     ██ ██ ██ ██ ██     Module Emulator V1.0     (c) 2023");
  serialOut("     ██ ██ ██ ██ ██     Modular Battery Technologies, Inc");
  serialOut("     ██    ██    ██");
  serialOut("     m o d b a t t");
  serialOut("");


	    // Switch state
    lastSwitchState.S1 = APP_SWITCH_RELEASED;

#ifdef TEST_SPI
    DRV_CANFDSPI_Reset(DRV_CANFDSPI_INDEX_0);

    appData.state = APP_STATE_TEST_RAM_ACCESS;

#else
    /* Place the App state machine in its initial state. */
    appData.state = APP_STATE_TEST_RAM_ACCESS;
#endif

}

/***************************************************************************************************************
*     A P P _ T a s k s                                                                P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_Tasks(void)
{


    /* Check the application's current state. */
    switch (appData.state) {
            /* Application's initial state. */
        case APP_STATE_INIT:
        {
          if (DEBUG > 1) serialOut("APP_STATE_INIT");
          //Nop();
          APP_LED_Set(APP_INIT_LED);
          APP_CANFDSPI_Init();
          APP_LED_Clear(APP_INIT_LED);

          appData.state = APP_STATE_IDLE;
          break;
        }
        case APP_STATE_IDLE:
        {
           // Check for unregistered modules and send announcements
          APP_AnnounceUnregisteredModules();
          break;
        }
        case APP_STATE_RECEIVE:
        {
          appData.state = APP_ReceiveMessage_Tasks();
          break;
        }
        case APP_STATE_TEST_RAM_ACCESS:             // RAM access test
        {
          bool passed = APP_TestRamAccess();
          if (passed) { sprintf(tempBuffer,"     MCP2518FD RAM TEST      : PASSED"); serialOut(tempBuffer);
          }else{        sprintf(tempBuffer,"     MCP2518FD RAM TEST      : FAILED"); serialOut(tempBuffer);
          }
          appData.state = APP_STATE_TEST_REGISTER_ACCESS;
          break;
        }
        case APP_STATE_TEST_REGISTER_ACCESS: /* Register access test */
        {
          bool passed = APP_TestRegisterAccess();
          if (passed) { sprintf(tempBuffer,"     MCP2518FD REGISTER TEST : PASSED"); serialOut(tempBuffer);
          }else{        sprintf(tempBuffer,"     MCP2518FD REGISTER TEST : FAILED"); serialOut(tempBuffer);
          }
          sprintf(tempBuffer," "); serialOut(tempBuffer);
          appData.state = APP_STATE_INIT;
          break;
        }
        // The default state should never be executed
        default:
        {
          /* TODO: Handle error in application's state machine. */
          appData.state = APP_STATE_INIT;
          break;
        }
    }
}

/***************************************************************************************************************
*
*                              Section: Application Local Functions
*
***************************************************************************************************************/


/***************************************************************************************************************
*     A P P _ C A N F D S P I _ I n i t                                                P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_CANFDSPI_Init(void)
{
    // Reset device
    DRV_CANFDSPI_Reset(DRV_CANFDSPI_INDEX_0);

    // Enable ECC and initialize RAM
    DRV_CANFDSPI_EccEnable(DRV_CANFDSPI_INDEX_0);

    DRV_CANFDSPI_RamInit(DRV_CANFDSPI_INDEX_0, 0xff);

    // Configure device
    DRV_CANFDSPI_ConfigureObjectReset(&config);
    config.IsoCrcEnable = 1;
    config.StoreInTEF = 0;

    DRV_CANFDSPI_Configure(DRV_CANFDSPI_INDEX_0, &config);

    // Setup TX FIFO
    DRV_CANFDSPI_TransmitChannelConfigureObjectReset(&txConfig);
    txConfig.FifoSize = 7;
    txConfig.PayLoadSize = CAN_PLSIZE_64;
    txConfig.TxPriority = 1;

    DRV_CANFDSPI_TransmitChannelConfigure(DRV_CANFDSPI_INDEX_0, APP_TX_FIFO, &txConfig);

    // Setup RX FIFO
    DRV_CANFDSPI_ReceiveChannelConfigureObjectReset(&rxConfig);
    rxConfig.FifoSize = 15;
    rxConfig.PayLoadSize = CAN_PLSIZE_64;

    DRV_CANFDSPI_ReceiveChannelConfigure(DRV_CANFDSPI_INDEX_0, APP_RX_FIFO, &rxConfig);

    // Setup RX Filter
    fObj.word = 0;
    //fObj.bF.SID = 0xda;
    fObj.bF.SID = 0x00;
    fObj.bF.EXIDE = 0;
    fObj.bF.EID = 0x00;

    DRV_CANFDSPI_FilterObjectConfigure(DRV_CANFDSPI_INDEX_0, CAN_FILTER0, &fObj.bF);

    // Setup RX Mask
    mObj.word = 0;
    mObj.bF.MSID = 0x0;
    mObj.bF.MIDE = 0; // Both standard and extended frames accepted
    mObj.bF.MEID = 0x0;
    DRV_CANFDSPI_FilterMaskConfigure(DRV_CANFDSPI_INDEX_0, CAN_FILTER0, &mObj.bF);

    // Link FIFO and Filter
    DRV_CANFDSPI_FilterToFifoLink(DRV_CANFDSPI_INDEX_0, CAN_FILTER0, APP_RX_FIFO, true);

    // Setup Bit Time
    DRV_CANFDSPI_BitTimeConfigure(DRV_CANFDSPI_INDEX_0, CAN_500K_2M, CAN_SSP_MODE_AUTO, CAN_SYSCLK_40M);

    // Setup Transmit and Receive Interrupts
    DRV_CANFDSPI_GpioModeConfigure(DRV_CANFDSPI_INDEX_0, GPIO_MODE_INT, GPIO_MODE_INT);
	#ifdef APP_USE_TX_INT
    DRV_CANFDSPI_TransmitChannelEventEnable(DRV_CANFDSPI_INDEX_0, APP_TX_FIFO, CAN_TX_FIFO_NOT_FULL_EVENT);
	#endif
    DRV_CANFDSPI_ReceiveChannelEventEnable(DRV_CANFDSPI_INDEX_0, APP_RX_FIFO, CAN_RX_FIFO_NOT_EMPTY_EVENT);
    DRV_CANFDSPI_ModuleEventEnable(DRV_CANFDSPI_INDEX_0, CAN_TX_EVENT | CAN_RX_EVENT);

    // Select Normal Mode
    DRV_CANFDSPI_OperationModeSelect(DRV_CANFDSPI_INDEX_0, CAN_NORMAL_MODE);
}

/***************************************************************************************************************
*     A P P _ R e c e i v e M e s s a g e _ T a s k s                                  P A C K   E M U L A T O R
***************************************************************************************************************/
APP_STATES APP_ReceiveMessage_Tasks(void)
{
    APP_STATES nextState;
    // CANFRM_REGISTER registration;
    //uint8_t index;

    // Check if FIFO is not empty
    DRV_CANFDSPI_ReceiveChannelEventGet(DRV_CANFDSPI_INDEX_0, APP_RX_FIFO, &rxFlags);

    while ( rxFlags & CAN_RX_FIFO_NOT_EMPTY_EVENT){

      // Get message
      DRV_CANFDSPI_ReceiveMessageGet(DRV_CANFDSPI_INDEX_0, APP_RX_FIFO, &rxObj, rxd, MAX_DATA_BYTES);

      switch (rxObj.bF.id.SID) {
        case ID_MODULE_REGISTRATION:
          APP_RegisterModule();
          break;
        case ID_MODULE_ALL_DEREGISTER   :
          APP_DeRegisterAllModules();
          break;
        case ID_MODULE_ALL_ISOLATE      :
          APP_IsolateAllModules();
          break;
        case ID_MODULE_DETAIL_REQUEST   :
          APP_ReplyToCellDetailRequest();
          break;
        case ID_MODULE_STATUS_REQUEST   :
          APP_ReplyToStatusRequest();
          break;
        case ID_MODULE_HARDWARE_REQUEST:
          APP_ProcessHardwareRequest();
          break;
        case ID_MODULE_STATE_CHANGE   :
          APP_StateChange();
        break;
      }

      // check for any more messages
      DRV_CANFDSPI_ReceiveChannelEventGet(DRV_CANFDSPI_INDEX_0, APP_RX_FIFO, &rxFlags);
    }

    //    APP_LED_Clear(APP_RX_LED);

    nextState = APP_STATE_IDLE;
    canRxInterrupt = 0;


    return nextState;
}
/***************************************************************************************************************
*     A P P _ T r a n s m i t M e s s a g e Q u e u e                                  P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitMessageQueue(void)
{
    APP_LED_Set(APP_TX_LED);

    uint8_t attempts = MAX_TXQUEUE_ATTEMPTS;

    // Check if FIFO is not full
    do {
        DRV_CANFDSPI_TransmitChannelEventGet(DRV_CANFDSPI_INDEX_0, APP_TX_FIFO, &txFlags);
        if (attempts == 0) {
            Nop();
            Nop();
            DRV_CANFDSPI_ErrorCountStateGet(DRV_CANFDSPI_INDEX_0, &tec, &rec, &errorFlags);
            return;
        }
        attempts--;
    }
    while (!(txFlags & CAN_TX_FIFO_NOT_FULL_EVENT));

    // Load message and transmit
    uint8_t n = DRV_CANFDSPI_DlcToDataBytes(txObj.bF.ctrl.DLC);

    DRV_CANFDSPI_TransmitChannelLoad(DRV_CANFDSPI_INDEX_0, APP_TX_FIFO, &txObj, txd, n, true);

    APP_LED_Clear(APP_TX_LED);
}

/***************************************************************************************************************
*     A P P _ A n n o u n c e U n r e g i s t e r e d M o d u l e s                    P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_AnnounceUnregisteredModules(void){

  uint8_t index;
  CANFRM_MODULE_ANNOUNCEMENT announcement;

  // check for unregistered modules and send out ANNOUNCE packets
  for(index = 0; index < MAX_MODULES_PER_PACK; index++){
    if((module[index].uniqueId != 0) && (module[index].moduleId == 0)){

      announcement.moduleFw = module[index].fwVersion;        // fill in the details
      announcement.modulePartId = module[index].partId;
      announcement.moduleMfgId = module[index].mfgId;
      announcement.moduleUniqueId = module[index].uniqueId;

      txObj.word[0] = 0;                              // Configure transmit message
      txObj.word[1] = 0;

      memcpy(txd, &announcement, 8);

      txObj.bF.id.SID = ID_MODULE_ANNOUNCEMENT     ;  // Standard ID
      txObj.bF.id.EID = 0;                            // Extended ID

      txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
      txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 8 bytes to transmit
      txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
      txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

      sprintf(tempBuffer,"TX 0x500 Announcement: FW=%02x, MFG=%02x, PN=%02x, ID=%08x",announcement.moduleFw, announcement.moduleMfgId, announcement.modulePartId,(int)announcement.moduleUniqueId); serialOut(tempBuffer);

      APP_TransmitMessageQueue();                     // Send it

      HAL_Delay(1000);
    }
  }
}

/***************************************************************************************************************
*     A P P _ T  r a n s m i t H a r d w a r e                                         P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitHardware(uint8_t index){

  CANFRM_MODULE_HARDWARE hardware;
  memset(&hardware,0,sizeof(hardware));

  hardware.hwVersion = module[index].hwVersion;
  hardware.maxChargeA = module[index].maxChargeA;
  hardware.maxDischargeA = module[index].maxDischargeA;
  hardware.maxChargeEndV = module[index].maxChargeEndV;


  txObj.word[0] = 0;                              // Configure transmit message
  txObj.word[1] = 0;
  txObj.word[2] = 0;

  memcpy(txd, &hardware, 12);

  txObj.bF.id.SID = ID_MODULE_HARDWARE ;          // Standard ID
  txObj.bF.id.EID = module[index].moduleId;       // Extended ID

  txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  txObj.bF.ctrl.DLC = CAN_DLC_8;                 // 8 bytes to transmit
  txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

  sprintf(tempBuffer,"TX 0x501 Hardware: ID=%02x, CHA=%d, DCA=%d, CHV=%d, HW=%d",
          rxObj.bF.id.EID, module[index].maxChargeA, module[index].maxDischargeA,  module[index].maxChargeEndV,module[index].hwVersion); serialOut(tempBuffer);

  APP_TransmitMessageQueue();                     // Send it

}


/***************************************************************************************************************
*     A P P _ T  r a n s m i t S t a t u s 1                                           P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitStatus1(uint8_t index){

  CANFRM_MODULE_STATUS_1 status;
  memset(&status,0,sizeof(status));

  status.moduleState = module[index].state;
  status.moduleSoc = module[index].soc;
  status.cellCount = module[index].cellCount;
  status.moduleSoh = module[index].soh;
  status.moduleMmc = module[index].mmc;
  status.moduleMmv = module[index].mmv;
  status.moduleStatus = module[index].status;

  txObj.word[0] = 0;                              // Configure transmit message
  txObj.word[1] = 0;
  txObj.word[2] = 0;

  memcpy(txd, &status, 12);

  txObj.bF.id.SID = ID_MODULE_STATUS_1 ;          // Standard ID
  txObj.bF.id.EID = module[index].moduleId;       // Extended ID

  txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  txObj.bF.ctrl.DLC = CAN_DLC_8;                 // 8 bytes to transmit
  txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

  sprintf(tempBuffer,"TX 0x502 Status1: ID=%02x STE=%02x STS=%d CNT=%d MMV=%d MMC=%d SOC=%d, SOH=%d",
        module[index].moduleId,module[index].state,module[index].status,module[index].cellCount,
        module[index].mmv,module[index].mmc,module[index].soc,module[index].soc); serialOut(tempBuffer);


  APP_TransmitMessageQueue();                     // Send it
  //APP_TransmitCellZeroDetails(index);
}

/***************************************************************************************************************
*     A P P _ T  r a n s m i t S t a t u s 2                                           P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitStatus2(uint8_t index){

  CANFRM_MODULE_STATUS_2 status;
  memset(&status,0,sizeof(status));

  status.cellAvgVolt = module[index].voltAvg;
  status.cellHiVolt = module[index].voltHi;
  status.cellLoVolt = module[index].voltLo;

  txObj.word[0] = 0;                              // Configure transmit message
  txObj.word[1] = 0;
  txObj.word[2] = 0;

  memcpy(txd, &status, 12);

  txObj.bF.id.SID = ID_MODULE_STATUS_2           ;          // Standard ID
  txObj.bF.id.EID = module[index].moduleId;                 // Extended ID

  txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  txObj.bF.ctrl.DLC = CAN_DLC_6;                  // 8 bytes to transmit
  txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

  sprintf(tempBuffer,"TX 0x503 Status2: ID=%02x HIV=%d LOV=%d AVG=%d",
      module[index].moduleId,  module[index].voltHi,module[index].voltLo, module[index].voltAvg); serialOut(tempBuffer);

  APP_TransmitMessageQueue();                     // Send it
  //APP_TransmitCellZeroDetails(index);
}

/***************************************************************************************************************
*     A P P _ T  r a n s m i t S t a t u s 3                                           P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitStatus3(uint8_t index){

  CANFRM_MODULE_STATUS_3 status;
  memset(&status,0,sizeof(status));


  status.cellHiTemp = module[index].tempHi;
  status.cellLoTemp = module[index].tempLo;
  status.cellAvgTemp = module[index].tempAvg;

  txObj.word[0] = 0;                              // Configure transmit message
  txObj.word[1] = 0;
  txObj.word[2] = 0;

  memcpy(txd, &status, 12);

  txObj.bF.id.SID = ID_MODULE_STATUS_3             ;          // Standard ID
  txObj.bF.id.EID = module[index].moduleId;                 // Extended ID

  txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 8 bytes to transmit
  txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

  sprintf(tempBuffer,"TX 0x504 Status3: ID=%02x HIT=%d LOT=%d AVG=%d",
        module[index].moduleId,  module[index].tempHi,module[index].tempLo, module[index].tempAvg); serialOut(tempBuffer);

  APP_TransmitMessageQueue();                     // Send it
  //APP_TransmitCellZeroDetails(index);
}

/***************************************************************************************************************
*     A P P _ T  r a n s m i t C e l l D e t a i l s                                   P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_TransmitCellZeroDetails(uint8_t index){

  CANFRM_MODULE_DETAIL cellDetail;

  // store the details
  cellDetail.cellCount   = module[index].cellCount;
  cellDetail.cellId      = 0;
  cellDetail.cellSoc     = module[index].cell[0].soc;
  cellDetail.cellTemp    = module[index].cell[0].temp ;
  cellDetail.cellVoltage = module[index].cell[0].voltage;
  cellDetail.cellSoh     = module[index].cell[0].soh;


  // clear bit fields
  txObj.word[0] = 0;                              // Configure transmit message
  txObj.word[1] = 0;
  txObj.word[2] = 0;

  memcpy(txd, &cellDetail, 8);

  txObj.bF.id.SID = ID_MODULE_DETAIL;             // Standard ID
  txObj.bF.id.EID = module[index].moduleId;       // Extended ID

  txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 3 bytes to transmit
  txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

  sprintf(tempBuffer,"TX 0x503 Cell Detail:  CNT=%02x, CELL=%02x, SOH=%02x SOC=%02x, TEMP=%03x, Voltage=%03x", cellDetail.cellCount, cellDetail.cellId, cellDetail.cellSoh, cellDetail.cellSoc, cellDetail.cellTemp, cellDetail.cellVoltage); serialOut(tempBuffer);
  APP_TransmitMessageQueue();                     // Send it
}

/***************************************************************************************************************
*     A P P _ P r o c e s s H a r d w a r e R e q u e s t                              P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_ProcessHardwareRequest(void){

   uint8_t moduleIndex = 0;
   uint8_t index;
   uint8_t moduleId;

   moduleId = rxObj.bF.id.EID;

   sprintf(tempBuffer,"RX 0x511 Hardware Request ID=%02x",moduleId); serialOut(tempBuffer);

 //find the index for the module
 moduleIndex = moduleCount; //default the index to the next entry (we are using 0 so next index is the moduleCount)
 for(index = 0; index < moduleCount; index++){
   if(moduleId == module[index].moduleId)
     moduleIndex = index; // module is already registered, save the index
 }
 if(moduleIndex != moduleCount) {
     // Transmit the hardware message
     APP_TransmitHardware(moduleIndex);
    }
 }

/***************************************************************************************************************
*     A P P _ R e p l y T o S t a t u s R e q u e s t                                  P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_ReplyToStatusRequest(void){

   uint8_t moduleIndex = 0;
   uint8_t index;
   uint8_t moduleId;

   moduleId = rxObj.bF.id.EID;

   sprintf(tempBuffer,"RX 0x512 Status Request ID=%02x",moduleId); serialOut(tempBuffer);

 //find the index for the module
 moduleIndex = moduleCount; //default the index to the next entry (we are using 0 so next index is the moduleCount)
 for(index = 0; index < moduleCount; index++){
   if(moduleId == module[index].moduleId)
     moduleIndex = index; // module is already registered, save the index
 }
 if(moduleIndex != moduleCount) {
     // Transmit the 3 status frames
     APP_TransmitStatus1(moduleIndex);
     APP_TransmitStatus2(moduleIndex);
     APP_TransmitStatus3(moduleIndex);
    }
 }




/***************************************************************************************************************
*     A P P _ R e p l y T o S t a t u s R e q u e s t                                  P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_StateChange(void){

   uint8_t moduleIndex = 0;
   uint8_t index;
   uint8_t moduleId;

   moduleId = rxObj.bF.id.EID;

   CANFRM_MODULE_STATE_CHANGE state;
   memcpy(&state, rxd,2);

 //find the index for the module
 moduleIndex = moduleCount; //default the index to the next entry (we are using 0 so next index is the moduleCount)
 for(index = 0; index < moduleCount; index++){
   if(moduleId == module[index].moduleId)
     moduleIndex = index; // module is already registered, save the index
 }
 if(moduleIndex != moduleCount){
   module[moduleIndex].state = state.state;

   sprintf(tempBuffer,"RX 0x514 State Change Request ID=%02x STATE=%02x",moduleId,state.state); serialOut(tempBuffer);
   // Transmit the 3 status frames
        APP_TransmitStatus1(moduleIndex);
        APP_TransmitStatus2(moduleIndex);
        APP_TransmitStatus3(moduleIndex);
   //APP_TransmitStatus(moduleIndex);
 }
}
/***************************************************************************************************************
*     A P P _ R e p l y T o C e l l D e t a i l R e q u e s t                          P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_ReplyToCellDetailRequest(void){

  CANFRM_MODULE_DETAIL_REQUEST detailRequest;
 CANFRM_MODULE_DETAIL cellDetail;
 uint8_t moduleIndex = 0;
 uint8_t index;

 // copy data to announcement structure
 memcpy(&detailRequest, rxd,3);
 sprintf(tempBuffer,"RX 0x515 Request detail: ID=%02x, CELL=%02x",detailRequest.moduleId,detailRequest.cellId ); serialOut(tempBuffer);

 //find the index for the module
 moduleIndex = moduleCount; //default the index to the next entry (we are using 0 so next index is the moduleCount)
 for(index = 0; index < moduleCount; index++){
   if(detailRequest.moduleId == module[index].moduleId)
     moduleIndex = index; // module is already registered, save the index
 }
 if(moduleIndex != moduleCount){
    // store the details
    cellDetail.cellCount   = module[moduleIndex].cellCount;
    cellDetail.cellId      = detailRequest.cellId;
    cellDetail.cellSoc     = module[moduleIndex].cell[detailRequest.cellId].soc;
    cellDetail.cellSoh     = module[moduleIndex].cell[detailRequest.cellId].soh;
    cellDetail.cellTemp    = module[moduleIndex].cell[detailRequest.cellId].temp ;
    cellDetail.cellVoltage = module[moduleIndex].cell[detailRequest.cellId].voltage;

    // clear bit fields
    txObj.word[0] = 0;                              // Configure transmit message
    txObj.word[1] = 0;
    txObj.word[2] = 0;

    memcpy(txd, &cellDetail, 8);

    txObj.bF.id.SID = ID_MODULE_DETAIL;             // Standard ID
    txObj.bF.id.EID = module[index].moduleId;       // Extended ID

    txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
    txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 3 bytes to transmit
    txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
    txObj.bF.ctrl.IDE = 1;                          // ID Extension selection - send base frame when cleared, extended frame when set

    sprintf(tempBuffer,"TX 0x505 Cell Detail: CNT=%02x, CELL=%02x, SOC=%02x, TEMP=%03x, Voltage=%03x", cellDetail.cellCount, cellDetail.cellId, cellDetail.cellSoc, cellDetail.cellTemp, cellDetail.cellVoltage); serialOut(tempBuffer);
     APP_TransmitMessageQueue();                     // Send it
   }else{
     // TODO : We couldn't find the module.
   }
}

/***************************************************************************************************************
*     A P P _  R e g i s t e r M o d u l e                                             P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_RegisterModule(void){

  CANFRM_MODULE_REGISTRATION registration;
  uint8_t index = 0;

  // copy data to announcement structure
  memcpy(&registration, rxd,8);
  //sprintf(tempBuffer,"RX 0x510 Registration: ID=%02x, CTL=%02x, MFG=%02x, PN=%02x, UID=%08x",registration.moduleId, registration.controllerId, registration.moduleMfgId, registration.modulePartId,(int)registration.moduleUniqueId); serialOut(tempBuffer);
  sprintf(tempBuffer,"RX 0x510 Registration: ID=%02x, CTL=%02x, MFG=%02x, PN=%02x, UID=%08x",rxObj.bF.id.EID, registration.controllerId, registration.moduleMfgId, registration.modulePartId,(int)registration.moduleUniqueId); serialOut(tempBuffer);

  // update our record
  for(index = 0; index < moduleCount; index++){
   if((registration.moduleMfgId == module[index].mfgId) && (registration.modulePartId == module[index].partId) && (registration.moduleUniqueId == module[index].uniqueId)){
      //module[index].moduleId = registration.moduleId;
      module[index].moduleId = rxObj.bF.id.EID;

      // Tranmist the 3 status frames
      APP_TransmitStatus1(index);
      APP_TransmitStatus2(index);
      APP_TransmitStatus3(index);
      APP_TransmitHardware(index);
    }
  }
}

/***************************************************************************************************************
*     A P P _ D e R e g i s t e r A l l M o d u l e s                                  P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_DeRegisterAllModules(void){

  uint8_t index;

  sprintf(tempBuffer,"RX 0x51E De-Register all modules"); serialOut(tempBuffer);
  for(index = 0; index < moduleCount; index++){
    module[index].moduleId = 0;
  }
}


/***************************************************************************************************************
*     A P P _ I s o la t e A l l M o d u l e s                                         P A C K   E M U L A T O R
***************************************************************************************************************/
void APP_IsolateAllModules(void){

  uint8_t index;

  sprintf(tempBuffer,"RX 0x51F Isolate all modules"); serialOut(tempBuffer);
  for(index = 0; index < moduleCount; index++){
    module[index].state = moduleOff;
  }
}

/***************************************************************************************************************
*     A P P _ T e s t R e g i s t e r A c c e s s                                      P A C K   E M U L A T O R
***************************************************************************************************************/
bool APP_TestRegisterAccess(void)
{
    // Variables
    uint8_t length;
    bool good = false;

    Nop();

    // Verify read/write with different access length
    // Note: registers can be accessed in multiples of bytes
    for (length = 1; length <= MAX_DATA_BYTES; length++) {
        for (i = 0; i < length; i++) {
            txd[i] = rand() & 0x7f; // Bit 31 of Filter objects is not implemented
            rxd[i] = 0xff;
        }

        Nop();

        // Write data to registers
        DRV_CANFDSPI_WriteByteArray(DRV_CANFDSPI_INDEX_0, cREGADDR_CiFLTOBJ, txd, length);

        // Read data back from registers
        DRV_CANFDSPI_ReadByteArray(DRV_CANFDSPI_INDEX_0, cREGADDR_CiFLTOBJ, rxd, length);

        // Verify
        good = false;
        for (i = 0; i < length; i++) {
            good = txd[i] == rxd[i];

            if (!good) {
                Nop();
                Nop();
                // Data mismatch
                return false;
            }
        }
    }
    Nop();
    Nop();
    return true;
}


/***************************************************************************************************************
*     A P P _ T e s t R a m A c c e s s                                                P A C K   E M U L A T O R
***************************************************************************************************************/
bool APP_TestRamAccess(void)
{
    // Variables
    uint8_t length;
    bool good = false;

    Nop();

    // Verify read/write with different access length
    // Note: RAM can only be accessed in multiples of 4 bytes
    for (length = 4; length <= MAX_DATA_BYTES; length += 4) {
        for (i = 0; i < length; i++) {
            txd[i] = rand() & 0xff;
            rxd[i] = 0xff;
        }

        Nop();

        // Write data to RAM
        DRV_CANFDSPI_WriteByteArray(DRV_CANFDSPI_INDEX_0, cRAMADDR_START, txd, length);

        // Read data back from RAM
        DRV_CANFDSPI_ReadByteArray(DRV_CANFDSPI_INDEX_0, cRAMADDR_START, rxd, length);

        // Verify
        good = false;
        for (i = 0; i < length; i++) {
            good = txd[i] == rxd[i];

            if (!good) {
                Nop();
                Nop();

                // Data mismatch
                return false;
            }
        }
    }

    return true;
}
