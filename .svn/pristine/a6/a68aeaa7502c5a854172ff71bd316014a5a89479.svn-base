/***************************************************************************************************************
 * @file           : vcu.c                                                         P A C K   C O N T R O L L E R
 * @brief          : Implementation of application
 ***************************************************************************************************************
 *
 * Copyright (c) 2023 VCUular Battery Technologies, Inc
 *
 **************************************************************************************************************/
// Include files
#include "vcu.h"
#include "main.h"
#include "app.h"
#include "bms.h"
#include <can_id_bms_vcu.h>
#include "canfdspi_api.h"
#include "string.h"
#include "stdio.h"
#include "can_frm_vcu.h"


/***************************************************************************************************************
*
*                               Section: Global Data Definitions                   P A C K   C O N T R O L L E R
*
***************************************************************************************************************/

// Transmit objects
CAN_TX_FIFO_CONFIG vcu_txConfig;
CAN_TX_FIFO_EVENT vcu_txFlags;
CAN_TX_MSGOBJ vcu_txObj;
uint8_t vcu_txd[MAX_DATA_BYTES];

// Receive objects
CAN_RX_FIFO_CONFIG vcu_rxConfig;
REG_CiFLTOBJ vcu_fObj;
REG_CiMASK vcu_mObj;
CAN_RX_FIFO_EVENT vcu_rxFlags;
CAN_RX_MSGOBJ vcu_rxObj;
uint8_t vcu_rxd[MAX_DATA_BYTES];


//CAN_BUS_DIAGNOSTIC busDiagnostics;
uint8_t vcu_tec;
uint8_t vcu_rec;
CAN_ERROR_STATE vcu_errorFlags;


void VCU_ProcessVcuCommand(void);
void VCU_ReceiveMessages(void);
void VCU_TransmitBmsData1(void);
void VCU_TransmitBmsData2(void);

extern batteryPack pack;
extern void MOD_TransmitState(uint8_t moduleId, moduleState state);



/***************************************************************************************************************
*
*                              Section: Application Local Functions
*
***************************************************************************************************************/



/***************************************************************************************************************
*     V C U _ R e c e i v e M o d u l e M e s s a g e s                            P A C K   C O N T R O L L E R
***************************************************************************************************************/

void VCU_ReceiveMessages(void)
{
    // Check if FIFO is not empty
    DRV_CANFDSPI_ReceiveChannelEventGet(CAN1, VCU_RX_FIFO, &vcu_rxFlags);

    while ( vcu_rxFlags & CAN_RX_FIFO_NOT_EMPTY_EVENT){

      // Get message
      DRV_CANFDSPI_ReceiveMessageGet(CAN1, VCU_RX_FIFO, &vcu_rxObj, vcu_rxd, MAX_DATA_BYTES);

      if(debugLevel & (DBG_VCU + DBG_VERBOSE)){ sprintf(tempBuffer,"VCU RX SID=0x%03x : Byte[0..7]=0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x",vcu_rxObj.bF.id.SID,vcu_rxd[0],vcu_rxd[1],vcu_rxd[2],vcu_rxd[3],vcu_rxd[4],vcu_rxd[5],vcu_rxd[6],vcu_rxd[7]); serialOut(tempBuffer);}

      //VCU_COMMAND
      if (vcu_rxObj.bF.id.SID == (ID_VCU_COMMAND +  pack.vcuCanOffset) ){

          VCU_ProcessVcuCommand();
      } else{
          // Unknown Message
          if(debugLevel & ( DBG_VCU + DBG_ERRORS)){ sprintf(tempBuffer,"VCU RX UNKNOWN SID=0x%03x : EID=0x%08x : Byte[0..7]=0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x",vcu_rxObj.bF.id.SID,vcu_rxObj.bF.id.EID,vcu_rxd[0],vcu_rxd[1],vcu_rxd[2],vcu_rxd[3],vcu_rxd[4],vcu_rxd[5],vcu_rxd[6],vcu_rxd[7]); serialOut(tempBuffer);}
      }

      // check for any more messages
      DRV_CANFDSPI_ReceiveChannelEventGet(CAN1, VCU_RX_FIFO, &vcu_rxFlags);
    }

    //    VCU_LED_Clear(VCU_RX_LED);
    //canRxInterrupt = 0;
}



/***************************************************************************************************************
*     V C U _ T r a n s m i t M e s s a g e Q u e u e                              P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitMessageQueue(CANFDSPI_MODULE_ID index)
{
//    MOD_LED_Set(VCU_TX_LED);
    uint8_t attempts = MAX_TXQUEUE_ATTEMPTS;

    // Check if FIFO is not full
    do {
        DRV_CANFDSPI_TransmitChannelEventGet(index, VCU_TX_FIFO, &vcu_txFlags);
        if (attempts == 0) {
            Nop();
            Nop();
            DRV_CANFDSPI_ErrorCountStateGet(index, &vcu_tec, &vcu_rec, &vcu_errorFlags);
            if(debugLevel & ( DBG_VCU + DBG_ERRORS)){ sprintf(tempBuffer,"VCU TX ERROR - FIFO FULL!"); serialOut(tempBuffer);}
            return;
        }
        attempts--;
    }
    while (!(vcu_txFlags & CAN_TX_FIFO_NOT_FULL_EVENT));

    // Load message and transmit
    uint8_t n = DRV_CANFDSPI_DlcToDataBytes(vcu_txObj.bF.ctrl.DLC);

    DRV_CANFDSPI_TransmitChannelLoad(index, VCU_TX_FIFO, &vcu_txObj, vcu_txd, n, true);

 //   VCU_LED_Clear(VCU_TX_LED);

}


/***************************************************************************************************************
*     M O D _ P r o c e s s M o d u l e S t a t u s 1                              P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_ProcessVcuCommand(void){

  CANFRM_0x400_VCU_COMMAND command;

  uint8_t moduleId;
  //uint8_t index;

  // Heartbeat - update last contact
  pack.vcuLastContact.overflows = etTimerOverflows ;
  pack.vcuLastContact.ticks =  htim1.Instance->CNT;

  // copy received data to status structure
  memset(&command,0,12);
  memcpy(&command, vcu_rxd, 12);

  if(pack.vcuRequestedState != command.vcu_contactor_ctrl){

    // change of state!
    pack.vcuRequestedState = command.vcu_contactor_ctrl;

    switch (pack.vcuRequestedState) {
            case packOn:
              // We need to select the module with the highest voltage
              moduleId = MOD_FindMaxVoltageModule();
              if (moduleId != pack.moduleCount +1 ){ //we have a valid ID
                // set the power stage
                pack.powerStatus.powerStage = stageFirstModule;
                // store the module Id
                pack.powerStatus.firstModuleId = moduleId;
                // Enable the module
                MOD_TransmitState(moduleId, moduleOn);
              }else{
                // No module was selected!
              }

              break;
            case packPrecharge:
              // Mechanical on for all modules, FET on for one module only
              // We need to select the module with the highest voltage and power it on - the rest will be issues the standby command
              moduleId = MOD_FindMaxVoltageModule();
              if (moduleId != pack.moduleCount +1 ){ //we have a valid ID
                // set the power stage
                pack.powerStatus.powerStage = stageFirstModule;
                // store the module Id
                pack.powerStatus.firstModuleId = moduleId;
                // Enable the module
                MOD_TransmitState(moduleId, moduleOn);
              }else{
                  // No module was selected!
              }
              break;
            case packOff:
              // Mechanical off, FET off for all modules (handled in app.c)
              break;
            case packStandby:
              // Mechanical on, FET off for all modules (handled in app.c)
              break;
            default:
              // Unknown Message
              if(debugLevel & (DBG_VCU + DBG_ERRORS)){ sprintf(tempBuffer,"VCU RX UNKNOWN REQUESTED STATE : 0x%02x",pack.vcuRequestedState); serialOut(tempBuffer);}
              break;
    }

  }

  if(debugLevel & DBG_VCU){ sprintf(tempBuffer,"VCU RX 0x%03x VCU Command : STATE=%02x", ID_VCU_COMMAND + PACK_ID, pack.vcuRequestedState); serialOut(tempBuffer);}

}

/***************************************************************************************************************
*    V C U _ T i c k s S i n c e L a s t M e s s a g e                             P A C K   C O N T R O L L E R
***************************************************************************************************************/

uint32_t VCU_TicksSinceLastMessage(void)
{
  uint32_t elapsedTicks;

    if ((etTimerOverflows - pack.vcuLastContact.overflows) == 0){
      elapsedTicks = htim1.Instance->CNT - pack.vcuLastContact.ticks;
    }else{
      //             (ticks last contact to overflow point)          + (              ticks in completed overflows                                  ) + ( ticks in current timer period)
      elapsedTicks = ((htim1.Init.Period +1) - pack.vcuLastContact.ticks) + ( (htim1.Init.Period +1) * (etTimerOverflows - (pack.vcuLastContact.overflows +1))) + (htim1.Instance->CNT);
    }
    return elapsedTicks;


}


/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s S t a t u s                                    P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsState(void){


  CANFRM_0x410_BMS_STATE bmsState;

  bmsState.bms_state                = pack.state;
  bmsState.bms_soh                  = pack.soh;
  bmsState.bms_status               = pack.status;
  bmsState.bms_cell_balance_status  = pack.cellBalanceStatus;
  bmsState.bms_cell_balance_active  = pack.cellBalanceActive;
  bmsState.bms_active_mod_cnt       = pack.activeModules;
  bmsState.bms_module_off           = pack.faultedModules;
  bmsState.bms_total_mod_cnt        = pack.moduleCount;
  bmsState.UNUSED_16                = 0;
  bmsState.UNUSED_31_63             = 0;

  // clear bit fields
  vcu_txObj.word[0] = 0;                              // Configure transmit message
  vcu_txObj.word[1] = 0;
  vcu_txObj.word[2] = 0;

  memcpy(vcu_txd, &bmsState, 8);

  vcu_txObj.bF.id.SID = ID_BMS_STATE;                 // Standard ID
  vcu_txObj.bF.id.EID = 0   ;                         // Extended ID

  vcu_txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  vcu_txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 8 bytes to transmit
  vcu_txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  vcu_txObj.bF.ctrl.IDE = 0;                          // ID Extension selection - send base frame when cleared, extended frame when set

  if(debugLevel &  DBG_VCU) {sprintf(tempBuffer,"VCU TX 0x%03x BMS_STATE",vcu_txObj.bF.id.SID); serialOut(tempBuffer);}

  VCU_TransmitMessageQueue(VCU_CAN);                     // Send it

}


/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 1                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData1(void){


  //0x421 BMS_DATA_1                     8 bytes  // Bits   Factor     Offset   Min     Max           Unit
  //uint32_t UNUSED_00_31                   : 32; // 00-31
  //uint32_t bms_pack_voltage               : 16; // 32-47  0.05       0        0       3276.75       Volts   The voltage level of the pack
  //uint32_t bms_pack_current               : 16; // 48-63  0.05       -1600    -1600   1676.75       Amps    The current in or out of the pack. A positive value represents current into (charging) the energy storage system.  A negative value represents current out of (discharging) the energy storage system.

  CANFRM_0x421_BMS_DATA_1 bmsData1;

  uint32_t totalCurrent = 0;
  uint16_t packCurrent  = 0;
  uint16_t packVoltage  = 0;
  uint16_t voltage      = 0;
  uint8_t index;
  uint8_t modulesOn     = 0;
  float   floatVoltage  = 0;
  float   floatCurrent  = 0;
  float   vcuValue      = 0;

  // sum the currents of all modules that are On - take voltage from the last one
  for(index = 0; index < pack.moduleCount; index++){
    if(module[index].current_state == moduleOn) {
      voltage = voltage + module[index].mmv;
      modulesOn++;
      totalCurrent = totalCurrent + module[index].mmc;
    }
  }
  //take average voltage
  voltage = voltage / modulesOn;


  if(totalCurrent >0){
    // To convert from 16-bit module value to current (Amps), current = base + (16-bit value * factor). Remember offset is -ve
    floatCurrent = MODULE_CURRENT_BASE + (MODULE_CURRENT_FACTOR * totalCurrent);
    // To convert a current(Amps) to a 16-bit VCU value, VCU value  = (current/factor) - (base/factor). Remember offset is -ve
    vcuValue = (floatCurrent/BMS_CURRENT_FACTOR)-(BMS_CURRENT_BASE/BMS_CURRENT_FACTOR);
    packCurrent = vcuValue;
  }else packCurrent = 0;

  if(voltage >0){
    // To convert from 16-bit module value to voltage (Volts), voltage = base + (16-bit value * factor). Remember offset is -ve
      floatVoltage = MODULE_VOLTAGE_BASE + (MODULE_VOLTAGE_FACTOR * voltage);
      // To convert a voltage (Volts) to a 16-bit VCU value, VCU value  = (voltage/factor) - (base/factor). Remember offset is -ve
      vcuValue = floatVoltage/BMS_VOLTAGE_FACTOR; // BMS_VOLTAGE_BASE is zero
      packVoltage = vcuValue;

  }else packVoltage = 0;

  bmsData1.bms_pack_current     = packCurrent;
  bmsData1.bms_pack_voltage     = packVoltage;
  bmsData1.UNUSED_00_31         = 0;

  // clear bit fields
  vcu_txObj.word[0] = 0;                              // Configure transmit message
  vcu_txObj.word[1] = 0;
  vcu_txObj.word[2] = 0;

  memcpy(vcu_txd, &bmsData1, 8);

  vcu_txObj.bF.id.SID = ID_BMS_DATA_1;                // Standard ID
  vcu_txObj.bF.id.EID = 0   ;                         // Extended ID

  vcu_txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  vcu_txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 8 bytes to transmit
  vcu_txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  vcu_txObj.bF.ctrl.IDE = 0;                          // ID Extension selection - send base frame when cleared, extended frame when set

  if(debugLevel &  DBG_VCU) {sprintf(tempBuffer,"VCU TX 0x%03x BMS_DATA_1",vcu_txObj.bF.id.SID); serialOut(tempBuffer);}

  VCU_TransmitMessageQueue(VCU_CAN);                     // Send it
}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 2                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData2(void){
 // 0x422 BMS_DATA_2                     8 bytes  // Bits   Factor     Offset   Min     Max           Unit
 // uint32_t bms_soc                        : 16; // 00-15  0.0015625  0        0       102.3984375   %        State of charge
 // uint32_t bms_high_cell_volt             : 16; // 16-31  0.001      0        0       65.535        Volts    Highest cell voltage reported by any cell
 // uint32_t bms_low_cell_volt              : 16; // 32-47  0.001      0        0       65.535        Volts    Lowest cell voltage reported by any cell
 // uint32_t bms_avg_cell_volt              : 16; // 48-63

  CANFRM_0x422_BMS_DATA_2 bmsData2;

  uint8_t index;
  uint32_t totalSoc =0;
  uint32_t totalAvgCellVolt = 0;
  uint16_t highestCellVolt = 0;
  uint16_t lowestCellVolt = 65535;
  uint16_t bmsSoc =0;
  uint16_t bmsAvgCellV =0;
  uint16_t bmsHiCellV =0;
  uint16_t bmsLoCellV =0;
  float   floatTemp  = 0;
  float   vcuValue      = 0;

  // Take average soc of all modules
  for(index = 0; index < pack.moduleCount; index++){
    totalSoc = totalSoc + module[index].soc;
    totalAvgCellVolt = totalAvgCellVolt + module[index].cellAvgVolt;
    if( module[index].cellHiVolt > highestCellVolt) highestCellVolt = module[index].cellHiVolt;
    if( module[index].cellLoVolt < lowestCellVolt) lowestCellVolt = module[index].cellLoVolt;
  }
  //SOC
  floatTemp = PERCENTAGE_BASE + (PERCENTAGE_FACTOR * (totalSoc / pack.moduleCount));
  vcuValue = floatTemp/BMS_PERCENTAGE_FACTOR; // BMS_PERCENTAGE_BASE is zero
  bmsSoc = vcuValue;

  //Avg Cell Volt
  floatTemp = CELL_VOLTAGE_BASE + (CELL_VOLTAGE_FACTOR * (totalAvgCellVolt / pack.moduleCount));
  vcuValue = floatTemp/BMS_CELL_VOLTAGE_FACTOR; // BMS_CELL_VOLTAGE_BASE is zero
  bmsAvgCellV = vcuValue;

  //High Cell Volt
  floatTemp = CELL_VOLTAGE_BASE + (CELL_VOLTAGE_FACTOR * highestCellVolt);
  vcuValue = floatTemp/BMS_CELL_VOLTAGE_FACTOR; // BMS_CELL_VOLTAGE_BASE is zero
  bmsHiCellV = vcuValue;

  //Low Cell Volt
  floatTemp = CELL_VOLTAGE_BASE + (CELL_VOLTAGE_FACTOR * lowestCellVolt);
  vcuValue = floatTemp/BMS_CELL_VOLTAGE_FACTOR; // BMS_CELL_VOLTAGE_BASE is zero
  bmsLoCellV = vcuValue;

  bmsData2.bms_soc = bmsSoc;
  bmsData2.bms_high_cell_volt = bmsHiCellV;
  bmsData2.bms_low_cell_volt = bmsLoCellV;
  bmsData2.bms_avg_cell_volt= bmsAvgCellV;

  // clear bit fields
  vcu_txObj.word[0] = 0;                              // Configure transmit message
  vcu_txObj.word[1] = 0;
  vcu_txObj.word[2] = 0;

  memcpy(vcu_txd, &bmsData2, 8);

  vcu_txObj.bF.id.SID = ID_BMS_DATA_2;                // Standard ID
  vcu_txObj.bF.id.EID = 0   ;                         // Extended ID

  vcu_txObj.bF.ctrl.BRS = 0;                          // Bit Rate Switch - use DBR when set, NBR when cleared
  vcu_txObj.bF.ctrl.DLC = CAN_DLC_8;                  // 8 bytes to transmit
  vcu_txObj.bF.ctrl.FDF = 0;                          // Frame Data Format - CAN FD when set, CAN 2.0 when cleared
  vcu_txObj.bF.ctrl.IDE = 0;                          // ID Extension selection - send base frame when cleared, extended frame when set

  if(debugLevel &  DBG_VCU) {sprintf(tempBuffer,"VCU TX 0x%03x BMS_DATA_2",vcu_txObj.bF.id.SID); serialOut(tempBuffer);}

  VCU_TransmitMessageQueue(VCU_CAN);                     // Send it
}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 3                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData3(void){
  /*
   * typedef struct {                                // 0x423 (was 0xCF092F3) BMS_DATA_3 - 8 bytes
                                                // Bits   Factor     Offset   Min     Max           Unit
  uint32_t bms_high_cell_temp             : 16; // 00-15  0.03125    -273     0       1774.96875    Degrees Celcius   Highest cell temperature reported by any cell
  uint32_t bms_low_cell_temp              : 16; // 16-31  0.03125    -273     0       1774.96875    Degrees Celcius   Lowest cell temperature reported by any cell
  uint32_t bms_avg_cell_temp              : 16; // 32-47  0.03125    -273     0       1774.96875    Degrees Celcius   The average temperature level of all cells
  uint32_t UNUSED_48_63                   : 16; // 48-63
 }CANFRM_0x423_BMS_DATA_3;
    */


}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 5                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData5(void){
  /*
   * typedef struct {                                // 0x425 (was 0xCF094F3) BMS_DATA_5 - 8 bytes
                                                 // Bits   Factor     Offset   Min     Max           Unit
   uint32_t bms_dischage_limit             : 16; // 00-15  0.05       -1600    -1600   1676.75       Amps     The maximum permissible current flow out of the High Voltage Energy Storage System
   uint32_t bms_charge_limit               : 16; // 16-31  0.05       -1600    -1600   1676.75       Amps     The maximum permissible current flow in to the High Voltage Energy Storage System
   uint32_t bms_charge_end_voltage_limit   : 16; // 32-47  0.05       0        0       3276.75       Volts    The maximum permissable voltage at end of charge
   uint32_t UNUSED_48_63                   : 16; // 48-63
  }CANFRM_0x425_BMS_DATA_5;
   *
   */
}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 8                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData8(void){
  /*
  typedef struct {                                // 0x428 (was 0xCF10AF3) BMS_DATA_8 - 8 bytes
                                                  // Bits   Factor     Offset   Min     Max           Unit
    uint32_t bms_max_volt_mod               : 8;  // 00-07  1          0        0       255                   Module number with highest cell voltage
    uint32_t bms_max_volt_cell              : 8;  // 08-15  1          0        0       255                   The number of the cell with highest voltage, within the module
    uint32_t bms_min_volt_mod               : 8;  // 16-23  1          0        0       255                   Module number with lowest cell voltage
    uint32_t bms_min_volt_cell              : 8;  // 24-31  1          0        0       255                   The number of the cell with lowest voltage,  within the module
    uint32_t bms_avg_cell_volt              : 16; // 32-39  0.001      0        0       65.535        Volts   The average cell voltage
    uint32_t UNUSED_48_63                   : 16; // 48-63
   }CANFRM_0x428_BMS_DATA_8;
   */
}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 9                                      P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData9(void){
  /*
   * typedef struct {                                // 0x429 (was 0xCF10BF3) BMS_DATA_9 - 8 bytes
                                                // Bits   Factor     Offset   Min     Max           Unit
  uint32_t bms_max_temp_mod               : 8;  // 00-07  1          0        0       255                       Module number with highest cell temperature
  uint32_t bms_max_temp_cell              : 8;  // 08-15  1          0        0       255                       The number of the cell with highest temperature, within the module
  uint32_t bms_min_temp_mod               : 8;  // 16-23  1          0        0       255                       Module number with lowest cell temperature
  uint32_t bms_min_temp_cell              : 8;  // 24-31  1          0        0       255                       The number of the cell with lowest temperature, within the module
  uint32_t UNUSED_32_63                   : 32; // 32-63
 }CANFRM_0x429_BMS_DATA_9;
   */
}

/***************************************************************************************************************
*     M O D _ T r a n s m i t B m s D a t a 1 0                                    P A C K   C O N T R O L L E R
***************************************************************************************************************/
void VCU_TransmitBmsData10(void){
  /*
   * typedef struct {                                // 0x430 (was 0xCF10CF3) BMS_DATA_10 - 8 bytes
                                                // Bits   Factor     Offset   Min     Max           Unit
  uint32_t bms_hv_bus_actv_iso            : 16; // 00-15  0.01       0        0       6553.5        Ohm/V        High-Voltage Bus Active Isolation Test Results
  uint32_t UNUSED_16_31                   : 16; // 16-31
  uint32_t UNUSED_32_63                   : 32; // 32-63
 }CANFRM_0x430_BMS_DATA_10;
   */
}






